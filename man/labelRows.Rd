% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/labelRows.R
\name{labelRows}
\alias{labelRows}
\title{Label and Remove metabCombiner Report Rows}
\usage{
labelRows(object, maxRankX = 3, maxRankY = 3, minScore = 0.3,
  conflict, method = c("score", "mzrt"), balanced = TRUE,
  remove = FALSE, brackets_ignore = c("(", "[", "{"))
}
\arguments{
\item{object}{Either a \code{metabCombiner} object or \code{combinedTable}.}

\item{maxRankX}{Integer. Maximum allowable rank for X dataset features.}

\item{maxRankY}{Integer. Maximum allowable rank for Y dataset features.}

\item{minScore}{Numeric. Minimum allowable score (between 0 & 1) for
metabolomics feature alignments.}

\item{conflict}{Numeric. If method = "score", a constant (between 0 & 1)
score difference between a pair of alignments.
If method = "mzrt", a length 4 numeric: (m/z, rt, m/z, rt)
tolerances, the first two for X dataset features and the
second two for Y dataset features.}

\item{method}{Conflict detection method. If equal to "score" (default method),
assigns a conflict subgroup if score of lower-ranking alignment
is within some tolerance of higher-ranking alignment. If set to
"mzrt", assigns a conflicting subgroup if within a small m/z &
rt distance of the top-ranked alignment.}

\item{balanced}{Logical. Optional processing of "balanced" groups (defined as
groups with equal numbers of features from X & Y datasets with
no conflicting top-matches).}

\item{remove}{Logical. Option to keep or discard rows deemed removable (labeled
"REMOVE" in \code{combinedTable})}

\item{brackets_ignore}{character. Bracketed identity strings of the types
in this argument will be ignored}
}
\value{
updated \code{combinedTable} or \code{metabCombiner} object. The
tabel will have three new columns:

\item{labels}{characterization of feature alignments as described}
\item{subgroup}{conflicting subgroup number of feature alignments}
\item{alt}{alternative subgroup for rows conflicting with multiple top-matches}
}
\description{
Automated method for determining identity-matching, removable, and conflicting
alignments in \code{combinedTable}. Optionally, removable rows may be
eliminated, resulting in a reduced \code{combinedTable}. Remaining alignments
that require further consideration are labeled "CONFLICT" and organized into
subgroups if they fall within some small measure (in score or mz/rt).
}
\details{
\code{metabCombiner} initially reports all possible feature alignments in the
 rows of \code{combinedTable} report. Most of these are misalignments that
 require inspection and removal. This function is used to automate most of the
 reduction process by labeling rows as removable or conflicting, based on
 certain conditions, and is performed after computing similarity scores.

 A label may take on one of four values:

 a) "": No determination made
 b) "IDENTITY": an alignment with matching identity "idx & idy" strings
 c) "REMOVE": a row determined to be a misalignment
 d) "CONFLICT": competing alignments for one or multiple shared features

The labeling rules are as follows:
1) Rows with matching idx & idy strings are labeled "IDENTITY". These rows
   are not labeled "REMOVE", irrespective of subsequent criteria.
2) Groups determined to be 'balanced': label rows with rankX > 1 & rankY > 1
   "REMOVE" irrespective of \code{conflict} criteria
3) Rows with a score < \code{minScore}: label "REMOVE"
4) Rows with rankX > \code{maxRankX} and/or rankY > \code{maxRankY}:
   label "REMOVE"
5) Conflicting subgroup assignment as determined  by \code{method} &
   \code{conflict} arguments. Conflicting alignments following outside
   \code{conflict} thresholds: labeled "REMOVE". Otherwise,
}
\examples{
\dontrun{
library(metabCombiner)
data(plasma30)
data(plasma20)

p30 <- metabData(plasma30, samples = "CHEAR")
p20 <- metabData(plasma20, samples = "Red", rtmax = 17.25)
p.combined = metabCombiner(xdata = p30, ydata = p20, binGap = 0.0075)
p.combined = selectAnchors(p.combined, tolMZ = 0.003, tolQ = 0.3, windY = 0.02)
p.combined = fit_gam(p.combined, k = seq(12,20,2), iterFilter = 1)
p.combined = calcScores(p.combined, A = 90, B = 14, C = 0.5)
cTable = combinedTable(p.combined)

##example using score-based conflict detection method
lTable = labelRows(cTable, method = "score", conflict = 0.2)

##example using mzrt-based conflict detection method
lTable = labelRows(cTable, method = "mzrt", conflict = c(0.005, 1, 0.005,0.5))

##example changing thresholds for rank and minimum score
lTable = labelRows(cTable, minScore = 0.5, maxRankX = 2, maxRankY = 2,
                   method = "score", conflict = 0.1)
}
}
